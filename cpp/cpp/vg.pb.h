// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vg.proto

#ifndef PROTOBUF_vg_2eproto__INCLUDED
#define PROTOBUF_vg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace vg {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_vg_2eproto();
void protobuf_AssignDesc_vg_2eproto();
void protobuf_ShutdownFile_vg_2eproto();

class Alignment;
class BasePileup;
class Edge;
class Edit;
class Fragment;
class Genotype;
class Graph;
class Info;
class KmerMatch;
class Mapping;
class Metadata;
class Node;
class NodePileup;
class Path;
class Position;

// ===================================================================

class Graph : public ::google::protobuf::Message {
 public:
  Graph();
  virtual ~Graph();

  Graph(const Graph& from);

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Graph& default_instance();

  void Swap(Graph* other);

  // implements Message ----------------------------------------------

  inline Graph* New() const { return New(NULL); }

  Graph* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Graph& from);
  void MergeFrom(const Graph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Graph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Node node = 1;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::vg::Node& node(int index) const;
  ::vg::Node* mutable_node(int index);
  ::vg::Node* add_node();
  ::google::protobuf::RepeatedPtrField< ::vg::Node >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::vg::Node >&
      node() const;

  // repeated .vg.Edge edge = 2;
  int edge_size() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 2;
  const ::vg::Edge& edge(int index) const;
  ::vg::Edge* mutable_edge(int index);
  ::vg::Edge* add_edge();
  ::google::protobuf::RepeatedPtrField< ::vg::Edge >*
      mutable_edge();
  const ::google::protobuf::RepeatedPtrField< ::vg::Edge >&
      edge() const;

  // repeated .vg.Path path = 3;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 3;
  const ::vg::Path& path(int index) const;
  ::vg::Path* mutable_path(int index);
  ::vg::Path* add_path();
  ::google::protobuf::RepeatedPtrField< ::vg::Path >*
      mutable_path();
  const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
      path() const;

  // optional .vg.Metadata metadata = 4;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 4;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // @@protoc_insertion_point(class_scope:vg.Graph)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::vg::Node > node_;
  ::google::protobuf::RepeatedPtrField< ::vg::Edge > edge_;
  ::google::protobuf::RepeatedPtrField< ::vg::Path > path_;
  ::vg::Metadata* metadata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Graph* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  inline Node* New() const { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int64 id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // optional bytes data = 4;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional .vg.Metadata metadata = 5;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 5;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // @@protoc_insertion_point(class_scope:vg.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::vg::Metadata* metadata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  inline Edge* New() const { return New(NULL); }

  Edge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  ::google::protobuf::int64 from() const;
  void set_from(::google::protobuf::int64 value);

  // optional int64 to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  ::google::protobuf::int64 to() const;
  void set_to(::google::protobuf::int64 value);

  // optional bool from_start = 3;
  void clear_from_start();
  static const int kFromStartFieldNumber = 3;
  bool from_start() const;
  void set_from_start(bool value);

  // optional bool to_end = 4;
  void clear_to_end();
  static const int kToEndFieldNumber = 4;
  bool to_end() const;
  void set_to_end(bool value);

  // optional bytes data = 5;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional .vg.Metadata metadata = 6;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // @@protoc_insertion_point(class_scope:vg.Edge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 from_;
  ::google::protobuf::int64 to_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::vg::Metadata* metadata_;
  bool from_start_;
  bool to_end_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Edge* default_instance_;
};
// -------------------------------------------------------------------

class Metadata : public ::google::protobuf::Message {
 public:
  Metadata();
  virtual ~Metadata();

  Metadata(const Metadata& from);

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metadata& default_instance();

  void Swap(Metadata* other);

  // implements Message ----------------------------------------------

  inline Metadata* New() const { return New(NULL); }

  Metadata* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Metadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .vg.Info> info = 1;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::vg::Info >&
      info() const;
  ::google::protobuf::Map< ::std::string, ::vg::Info >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:vg.Metadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::vg::Info,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      Metadata_InfoEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::vg::Info,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > info_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Metadata* default_instance_;
};
// -------------------------------------------------------------------

class Info : public ::google::protobuf::Message {
 public:
  Info();
  virtual ~Info();

  Info(const Info& from);

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Info& default_instance();

  void Swap(Info* other);

  // implements Message ----------------------------------------------

  inline Info* New() const { return New(NULL); }

  Info* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Info& from);
  void MergeFrom(const Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string str = 2;
  void clear_str();
  static const int kStrFieldNumber = 2;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // optional int64 int = 3;
  void clear_int_();
  static const int kIntFieldNumber = 3;
  ::google::protobuf::int64 int_() const;
  void set_int_(::google::protobuf::int64 value);

  // optional bytes data = 4;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional .vg.Metadata metadata = 5;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 5;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // @@protoc_insertion_point(class_scope:vg.Info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr str_;
  ::google::protobuf::int64 int__;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::vg::Metadata* metadata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Info* default_instance_;
};
// -------------------------------------------------------------------

class Edit : public ::google::protobuf::Message {
 public:
  Edit();
  virtual ~Edit();

  Edit(const Edit& from);

  inline Edit& operator=(const Edit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edit& default_instance();

  void Swap(Edit* other);

  // implements Message ----------------------------------------------

  inline Edit* New() const { return New(NULL); }

  Edit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edit& from);
  void MergeFrom(const Edit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Edit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 from_length = 1;
  void clear_from_length();
  static const int kFromLengthFieldNumber = 1;
  ::google::protobuf::int32 from_length() const;
  void set_from_length(::google::protobuf::int32 value);

  // optional int32 to_length = 2;
  void clear_to_length();
  static const int kToLengthFieldNumber = 2;
  ::google::protobuf::int32 to_length() const;
  void set_to_length(::google::protobuf::int32 value);

  // optional string sequence = 3;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional .vg.Metadata metadata = 4;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 4;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // @@protoc_insertion_point(class_scope:vg.Edit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 from_length_;
  ::google::protobuf::int32 to_length_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::vg::Metadata* metadata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Edit* default_instance_;
};
// -------------------------------------------------------------------

class Mapping : public ::google::protobuf::Message {
 public:
  Mapping();
  virtual ~Mapping();

  Mapping(const Mapping& from);

  inline Mapping& operator=(const Mapping& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mapping& default_instance();

  void Swap(Mapping* other);

  // implements Message ----------------------------------------------

  inline Mapping* New() const { return New(NULL); }

  Mapping* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mapping& from);
  void MergeFrom(const Mapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vg.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::vg::Position& position() const;
  ::vg::Position* mutable_position();
  ::vg::Position* release_position();
  void set_allocated_position(::vg::Position* position);

  // repeated .vg.Edit edit = 2;
  int edit_size() const;
  void clear_edit();
  static const int kEditFieldNumber = 2;
  const ::vg::Edit& edit(int index) const;
  ::vg::Edit* mutable_edit(int index);
  ::vg::Edit* add_edit();
  ::google::protobuf::RepeatedPtrField< ::vg::Edit >*
      mutable_edit();
  const ::google::protobuf::RepeatedPtrField< ::vg::Edit >&
      edit() const;

  // optional int64 rank = 5;
  void clear_rank();
  static const int kRankFieldNumber = 5;
  ::google::protobuf::int64 rank() const;
  void set_rank(::google::protobuf::int64 value);

  // optional .vg.Metadata metadata = 4;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 4;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // @@protoc_insertion_point(class_scope:vg.Mapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::vg::Position* position_;
  ::google::protobuf::RepeatedPtrField< ::vg::Edit > edit_;
  ::google::protobuf::int64 rank_;
  ::vg::Metadata* metadata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Mapping* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // optional int64 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // optional .vg.Metadata metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // optional bool is_reverse = 4;
  void clear_is_reverse();
  static const int kIsReverseFieldNumber = 4;
  bool is_reverse() const;
  void set_is_reverse(bool value);

  // @@protoc_insertion_point(class_scope:vg.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 node_id_;
  ::google::protobuf::int64 offset_;
  ::vg::Metadata* metadata_;
  bool is_reverse_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::Message {
 public:
  Path();
  virtual ~Path();

  Path(const Path& from);

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Path& default_instance();

  void Swap(Path* other);

  // implements Message ----------------------------------------------

  inline Path* New() const { return New(NULL); }

  Path* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Path* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .vg.Mapping mapping = 2;
  int mapping_size() const;
  void clear_mapping();
  static const int kMappingFieldNumber = 2;
  const ::vg::Mapping& mapping(int index) const;
  ::vg::Mapping* mutable_mapping(int index);
  ::vg::Mapping* add_mapping();
  ::google::protobuf::RepeatedPtrField< ::vg::Mapping >*
      mutable_mapping();
  const ::google::protobuf::RepeatedPtrField< ::vg::Mapping >&
      mapping() const;

  // optional .vg.Metadata metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // @@protoc_insertion_point(class_scope:vg.Path)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::vg::Mapping > mapping_;
  ::vg::Metadata* metadata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Path* default_instance_;
};
// -------------------------------------------------------------------

class Alignment : public ::google::protobuf::Message {
 public:
  Alignment();
  virtual ~Alignment();

  Alignment(const Alignment& from);

  inline Alignment& operator=(const Alignment& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Alignment& default_instance();

  void Swap(Alignment* other);

  // implements Message ----------------------------------------------

  inline Alignment* New() const { return New(NULL); }

  Alignment* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alignment& from);
  void MergeFrom(const Alignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Alignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional .vg.Path path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::vg::Path& path() const;
  ::vg::Path* mutable_path();
  ::vg::Path* release_path();
  void set_allocated_path(::vg::Path* path);

  // optional string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes quality = 4;
  void clear_quality();
  static const int kQualityFieldNumber = 4;
  const ::std::string& quality() const;
  void set_quality(const ::std::string& value);
  void set_quality(const char* value);
  void set_quality(const void* value, size_t size);
  ::std::string* mutable_quality();
  ::std::string* release_quality();
  void set_allocated_quality(::std::string* quality);

  // optional int32 mapping_quality = 5;
  void clear_mapping_quality();
  static const int kMappingQualityFieldNumber = 5;
  ::google::protobuf::int32 mapping_quality() const;
  void set_mapping_quality(::google::protobuf::int32 value);

  // optional int32 score = 6;
  void clear_score();
  static const int kScoreFieldNumber = 6;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // optional int32 query_position = 7;
  void clear_query_position();
  static const int kQueryPositionFieldNumber = 7;
  ::google::protobuf::int32 query_position() const;
  void set_query_position(::google::protobuf::int32 value);

  // optional string sample_name = 9;
  void clear_sample_name();
  static const int kSampleNameFieldNumber = 9;
  const ::std::string& sample_name() const;
  void set_sample_name(const ::std::string& value);
  void set_sample_name(const char* value);
  void set_sample_name(const char* value, size_t size);
  ::std::string* mutable_sample_name();
  ::std::string* release_sample_name();
  void set_allocated_sample_name(::std::string* sample_name);

  // optional string read_group = 10;
  void clear_read_group();
  static const int kReadGroupFieldNumber = 10;
  const ::std::string& read_group() const;
  void set_read_group(const ::std::string& value);
  void set_read_group(const char* value);
  void set_read_group(const char* value, size_t size);
  ::std::string* mutable_read_group();
  ::std::string* release_read_group();
  void set_allocated_read_group(::std::string* read_group);

  // optional .vg.Alignment fragment_prev = 11;
  bool has_fragment_prev() const;
  void clear_fragment_prev();
  static const int kFragmentPrevFieldNumber = 11;
  const ::vg::Alignment& fragment_prev() const;
  ::vg::Alignment* mutable_fragment_prev();
  ::vg::Alignment* release_fragment_prev();
  void set_allocated_fragment_prev(::vg::Alignment* fragment_prev);

  // optional .vg.Alignment fragment_next = 12;
  bool has_fragment_next() const;
  void clear_fragment_next();
  static const int kFragmentNextFieldNumber = 12;
  const ::vg::Alignment& fragment_next() const;
  ::vg::Alignment* mutable_fragment_next();
  ::vg::Alignment* release_fragment_next();
  void set_allocated_fragment_next(::vg::Alignment* fragment_next);

  // optional bytes data = 13;
  void clear_data();
  static const int kDataFieldNumber = 13;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional .vg.Metadata metadata = 14;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 14;
  const ::vg::Metadata& metadata() const;
  ::vg::Metadata* mutable_metadata();
  ::vg::Metadata* release_metadata();
  void set_allocated_metadata(::vg::Metadata* metadata);

  // optional bool is_secondary = 15;
  void clear_is_secondary();
  static const int kIsSecondaryFieldNumber = 15;
  bool is_secondary() const;
  void set_is_secondary(bool value);

  // @@protoc_insertion_point(class_scope:vg.Alignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::vg::Path* path_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr quality_;
  ::google::protobuf::int32 mapping_quality_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::internal::ArenaStringPtr sample_name_;
  ::google::protobuf::internal::ArenaStringPtr read_group_;
  ::vg::Alignment* fragment_prev_;
  ::google::protobuf::int32 query_position_;
  bool is_secondary_;
  ::vg::Alignment* fragment_next_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::vg::Metadata* metadata_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Alignment* default_instance_;
};
// -------------------------------------------------------------------

class Fragment : public ::google::protobuf::Message {
 public:
  Fragment();
  virtual ~Fragment();

  Fragment(const Fragment& from);

  inline Fragment& operator=(const Fragment& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fragment& default_instance();

  void Swap(Fragment* other);

  // implements Message ----------------------------------------------

  inline Fragment* New() const { return New(NULL); }

  Fragment* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Fragment& from);
  void MergeFrom(const Fragment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fragment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Alignment alignment = 1;
  int alignment_size() const;
  void clear_alignment();
  static const int kAlignmentFieldNumber = 1;
  const ::vg::Alignment& alignment(int index) const;
  ::vg::Alignment* mutable_alignment(int index);
  ::vg::Alignment* add_alignment();
  ::google::protobuf::RepeatedPtrField< ::vg::Alignment >*
      mutable_alignment();
  const ::google::protobuf::RepeatedPtrField< ::vg::Alignment >&
      alignment() const;

  // @@protoc_insertion_point(class_scope:vg.Fragment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::vg::Alignment > alignment_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Fragment* default_instance_;
};
// -------------------------------------------------------------------

class KmerMatch : public ::google::protobuf::Message {
 public:
  KmerMatch();
  virtual ~KmerMatch();

  KmerMatch(const KmerMatch& from);

  inline KmerMatch& operator=(const KmerMatch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KmerMatch& default_instance();

  void Swap(KmerMatch* other);

  // implements Message ----------------------------------------------

  inline KmerMatch* New() const { return New(NULL); }

  KmerMatch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KmerMatch& from);
  void MergeFrom(const KmerMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KmerMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional int64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // optional sint32 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // optional bool backward = 4;
  void clear_backward();
  static const int kBackwardFieldNumber = 4;
  bool backward() const;
  void set_backward(bool value);

  // @@protoc_insertion_point(class_scope:vg.KmerMatch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::int64 node_id_;
  ::google::protobuf::int32 position_;
  bool backward_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static KmerMatch* default_instance_;
};
// -------------------------------------------------------------------

class BasePileup : public ::google::protobuf::Message {
 public:
  BasePileup();
  virtual ~BasePileup();

  BasePileup(const BasePileup& from);

  inline BasePileup& operator=(const BasePileup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasePileup& default_instance();

  void Swap(BasePileup* other);

  // implements Message ----------------------------------------------

  inline BasePileup* New() const { return New(NULL); }

  BasePileup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasePileup& from);
  void MergeFrom(const BasePileup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BasePileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ref_base = 1;
  void clear_ref_base();
  static const int kRefBaseFieldNumber = 1;
  ::google::protobuf::int32 ref_base() const;
  void set_ref_base(::google::protobuf::int32 value);

  // optional int32 num_bases = 2;
  void clear_num_bases();
  static const int kNumBasesFieldNumber = 2;
  ::google::protobuf::int32 num_bases() const;
  void set_num_bases(::google::protobuf::int32 value);

  // optional string bases = 3;
  void clear_bases();
  static const int kBasesFieldNumber = 3;
  const ::std::string& bases() const;
  void set_bases(const ::std::string& value);
  void set_bases(const char* value);
  void set_bases(const char* value, size_t size);
  ::std::string* mutable_bases();
  ::std::string* release_bases();
  void set_allocated_bases(::std::string* bases);

  // optional bytes qualities = 4;
  void clear_qualities();
  static const int kQualitiesFieldNumber = 4;
  const ::std::string& qualities() const;
  void set_qualities(const ::std::string& value);
  void set_qualities(const char* value);
  void set_qualities(const void* value, size_t size);
  ::std::string* mutable_qualities();
  ::std::string* release_qualities();
  void set_allocated_qualities(::std::string* qualities);

  // @@protoc_insertion_point(class_scope:vg.BasePileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 ref_base_;
  ::google::protobuf::int32 num_bases_;
  ::google::protobuf::internal::ArenaStringPtr bases_;
  ::google::protobuf::internal::ArenaStringPtr qualities_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static BasePileup* default_instance_;
};
// -------------------------------------------------------------------

class NodePileup : public ::google::protobuf::Message {
 public:
  NodePileup();
  virtual ~NodePileup();

  NodePileup(const NodePileup& from);

  inline NodePileup& operator=(const NodePileup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodePileup& default_instance();

  void Swap(NodePileup* other);

  // implements Message ----------------------------------------------

  inline NodePileup* New() const { return New(NULL); }

  NodePileup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodePileup& from);
  void MergeFrom(const NodePileup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodePileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // repeated .vg.BasePileup base_pileup = 2;
  int base_pileup_size() const;
  void clear_base_pileup();
  static const int kBasePileupFieldNumber = 2;
  const ::vg::BasePileup& base_pileup(int index) const;
  ::vg::BasePileup* mutable_base_pileup(int index);
  ::vg::BasePileup* add_base_pileup();
  ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >*
      mutable_base_pileup();
  const ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >&
      base_pileup() const;

  // @@protoc_insertion_point(class_scope:vg.NodePileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 node_id_;
  ::google::protobuf::RepeatedPtrField< ::vg::BasePileup > base_pileup_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static NodePileup* default_instance_;
};
// -------------------------------------------------------------------

class Genotype : public ::google::protobuf::Message {
 public:
  Genotype();
  virtual ~Genotype();

  Genotype(const Genotype& from);

  inline Genotype& operator=(const Genotype& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Genotype& default_instance();

  void Swap(Genotype* other);

  // implements Message ----------------------------------------------

  inline Genotype* New() const { return New(NULL); }

  Genotype* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Genotype& from);
  void MergeFrom(const Genotype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Genotype* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Path allele = 1;
  int allele_size() const;
  void clear_allele();
  static const int kAlleleFieldNumber = 1;
  const ::vg::Path& allele(int index) const;
  ::vg::Path* mutable_allele(int index);
  ::vg::Path* add_allele();
  ::google::protobuf::RepeatedPtrField< ::vg::Path >*
      mutable_allele();
  const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
      allele() const;

  // optional .vg.Position start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::vg::Position& start() const;
  ::vg::Position* mutable_start();
  ::vg::Position* release_start();
  void set_allocated_start(::vg::Position* start);

  // optional .vg.Position end = 3;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 3;
  const ::vg::Position& end() const;
  ::vg::Position* mutable_end();
  ::vg::Position* release_end();
  void set_allocated_end(::vg::Position* end);

  // @@protoc_insertion_point(class_scope:vg.Genotype)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::vg::Path > allele_;
  ::vg::Position* start_;
  ::vg::Position* end_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Genotype* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Graph

// repeated .vg.Node node = 1;
inline int Graph::node_size() const {
  return node_.size();
}
inline void Graph::clear_node() {
  node_.Clear();
}
inline const ::vg::Node& Graph::node(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.node)
  return node_.Get(index);
}
inline ::vg::Node* Graph::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.node)
  return node_.Mutable(index);
}
inline ::vg::Node* Graph::add_node() {
  // @@protoc_insertion_point(field_add:vg.Graph.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Node >*
Graph::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Node >&
Graph::node() const {
  // @@protoc_insertion_point(field_list:vg.Graph.node)
  return node_;
}

// repeated .vg.Edge edge = 2;
inline int Graph::edge_size() const {
  return edge_.size();
}
inline void Graph::clear_edge() {
  edge_.Clear();
}
inline const ::vg::Edge& Graph::edge(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.edge)
  return edge_.Get(index);
}
inline ::vg::Edge* Graph::mutable_edge(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.edge)
  return edge_.Mutable(index);
}
inline ::vg::Edge* Graph::add_edge() {
  // @@protoc_insertion_point(field_add:vg.Graph.edge)
  return edge_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Edge >*
Graph::mutable_edge() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.edge)
  return &edge_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Edge >&
Graph::edge() const {
  // @@protoc_insertion_point(field_list:vg.Graph.edge)
  return edge_;
}

// repeated .vg.Path path = 3;
inline int Graph::path_size() const {
  return path_.size();
}
inline void Graph::clear_path() {
  path_.Clear();
}
inline const ::vg::Path& Graph::path(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.path)
  return path_.Get(index);
}
inline ::vg::Path* Graph::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.path)
  return path_.Mutable(index);
}
inline ::vg::Path* Graph::add_path() {
  // @@protoc_insertion_point(field_add:vg.Graph.path)
  return path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Path >*
Graph::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.path)
  return &path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
Graph::path() const {
  // @@protoc_insertion_point(field_list:vg.Graph.path)
  return path_;
}

// optional .vg.Metadata metadata = 4;
inline bool Graph::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Graph::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Graph::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Graph.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Graph::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Graph.metadata)
  return metadata_;
}
inline ::vg::Metadata* Graph::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Graph::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Graph.metadata)
}

// -------------------------------------------------------------------

// Node

// optional string sequence = 1;
inline void Node::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Node.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Node.sequence)
}
inline void Node::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Node.sequence)
}
inline void Node::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Node.sequence)
}
inline ::std::string* Node::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Node.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_sequence() {
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Node.sequence)
}

// optional string name = 2;
inline void Node::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:vg.Node.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Node.name)
}
inline void Node::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Node.name)
}
inline void Node::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Node.name)
}
inline ::std::string* Node::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Node.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_name() {
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Node.name)
}

// optional int64 id = 3;
inline void Node::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Node::id() const {
  // @@protoc_insertion_point(field_get:vg.Node.id)
  return id_;
}
inline void Node::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:vg.Node.id)
}

// optional bytes data = 4;
inline void Node::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::data() const {
  // @@protoc_insertion_point(field_get:vg.Node.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Node.data)
}
inline void Node::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Node.data)
}
inline void Node::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Node.data)
}
inline ::std::string* Node::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:vg.Node.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_data() {
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:vg.Node.data)
}

// optional .vg.Metadata metadata = 5;
inline bool Node::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Node::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Node::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Node.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Node::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Node.metadata)
  return metadata_;
}
inline ::vg::Metadata* Node::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Node::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Node.metadata)
}

// -------------------------------------------------------------------

// Edge

// optional int64 from = 1;
inline void Edge::clear_from() {
  from_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::from() const {
  // @@protoc_insertion_point(field_get:vg.Edge.from)
  return from_;
}
inline void Edge::set_from(::google::protobuf::int64 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.from)
}

// optional int64 to = 2;
inline void Edge::clear_to() {
  to_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::to() const {
  // @@protoc_insertion_point(field_get:vg.Edge.to)
  return to_;
}
inline void Edge::set_to(::google::protobuf::int64 value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.to)
}

// optional bool from_start = 3;
inline void Edge::clear_from_start() {
  from_start_ = false;
}
inline bool Edge::from_start() const {
  // @@protoc_insertion_point(field_get:vg.Edge.from_start)
  return from_start_;
}
inline void Edge::set_from_start(bool value) {
  
  from_start_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.from_start)
}

// optional bool to_end = 4;
inline void Edge::clear_to_end() {
  to_end_ = false;
}
inline bool Edge::to_end() const {
  // @@protoc_insertion_point(field_get:vg.Edge.to_end)
  return to_end_;
}
inline void Edge::set_to_end(bool value) {
  
  to_end_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.to_end)
}

// optional bytes data = 5;
inline void Edge::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Edge::data() const {
  // @@protoc_insertion_point(field_get:vg.Edge.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Edge.data)
}
inline void Edge::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Edge.data)
}
inline void Edge::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Edge.data)
}
inline ::std::string* Edge::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:vg.Edge.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edge::release_data() {
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edge::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:vg.Edge.data)
}

// optional .vg.Metadata metadata = 6;
inline bool Edge::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Edge::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Edge::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Edge.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Edge::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Edge.metadata)
  return metadata_;
}
inline ::vg::Metadata* Edge::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Edge::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Edge.metadata)
}

// -------------------------------------------------------------------

// Metadata

// map<string, .vg.Info> info = 1;
inline int Metadata::info_size() const {
  return info_.size();
}
inline void Metadata::clear_info() {
  info_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::vg::Info >&
Metadata::info() const {
  // @@protoc_insertion_point(field_map:vg.Metadata.info)
  return info_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::vg::Info >*
Metadata::mutable_info() {
  // @@protoc_insertion_point(field_mutable_map:vg.Metadata.info)
  return info_.MutableMap();
}

// -------------------------------------------------------------------

// Info

// optional string id = 1;
inline void Info::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Info::id() const {
  // @@protoc_insertion_point(field_get:vg.Info.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Info.id)
}
inline void Info::set_id(const char* value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Info.id)
}
inline void Info::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Info.id)
}
inline ::std::string* Info::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:vg.Info.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Info::release_id() {
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:vg.Info.id)
}

// optional string str = 2;
inline void Info::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Info::str() const {
  // @@protoc_insertion_point(field_get:vg.Info.str)
  return str_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_str(const ::std::string& value) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Info.str)
}
inline void Info::set_str(const char* value) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Info.str)
}
inline void Info::set_str(const char* value, size_t size) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Info.str)
}
inline ::std::string* Info::mutable_str() {
  
  // @@protoc_insertion_point(field_mutable:vg.Info.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Info::release_str() {
  
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    
  } else {
    
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:vg.Info.str)
}

// optional int64 int = 3;
inline void Info::clear_int_() {
  int__ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Info::int_() const {
  // @@protoc_insertion_point(field_get:vg.Info.int)
  return int__;
}
inline void Info::set_int_(::google::protobuf::int64 value) {
  
  int__ = value;
  // @@protoc_insertion_point(field_set:vg.Info.int)
}

// optional bytes data = 4;
inline void Info::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Info::data() const {
  // @@protoc_insertion_point(field_get:vg.Info.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Info.data)
}
inline void Info::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Info.data)
}
inline void Info::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Info.data)
}
inline ::std::string* Info::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:vg.Info.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Info::release_data() {
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Info::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:vg.Info.data)
}

// optional .vg.Metadata metadata = 5;
inline bool Info::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Info::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Info::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Info.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Info::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Info.metadata)
  return metadata_;
}
inline ::vg::Metadata* Info::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Info::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Info.metadata)
}

// -------------------------------------------------------------------

// Edit

// optional int32 from_length = 1;
inline void Edit::clear_from_length() {
  from_length_ = 0;
}
inline ::google::protobuf::int32 Edit::from_length() const {
  // @@protoc_insertion_point(field_get:vg.Edit.from_length)
  return from_length_;
}
inline void Edit::set_from_length(::google::protobuf::int32 value) {
  
  from_length_ = value;
  // @@protoc_insertion_point(field_set:vg.Edit.from_length)
}

// optional int32 to_length = 2;
inline void Edit::clear_to_length() {
  to_length_ = 0;
}
inline ::google::protobuf::int32 Edit::to_length() const {
  // @@protoc_insertion_point(field_get:vg.Edit.to_length)
  return to_length_;
}
inline void Edit::set_to_length(::google::protobuf::int32 value) {
  
  to_length_ = value;
  // @@protoc_insertion_point(field_set:vg.Edit.to_length)
}

// optional string sequence = 3;
inline void Edit::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Edit::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Edit.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edit::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Edit.sequence)
}
inline void Edit::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Edit.sequence)
}
inline void Edit::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Edit.sequence)
}
inline ::std::string* Edit::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Edit.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edit::release_sequence() {
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edit::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Edit.sequence)
}

// optional .vg.Metadata metadata = 4;
inline bool Edit::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Edit::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Edit::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Edit.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Edit::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Edit.metadata)
  return metadata_;
}
inline ::vg::Metadata* Edit::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Edit::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Edit.metadata)
}

// -------------------------------------------------------------------

// Mapping

// optional .vg.Position position = 1;
inline bool Mapping::has_position() const {
  return !_is_default_instance_ && position_ != NULL;
}
inline void Mapping::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) delete position_;
  position_ = NULL;
}
inline const ::vg::Position& Mapping::position() const {
  // @@protoc_insertion_point(field_get:vg.Mapping.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::vg::Position* Mapping::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::vg::Position;
  }
  // @@protoc_insertion_point(field_mutable:vg.Mapping.position)
  return position_;
}
inline ::vg::Position* Mapping::release_position() {
  
  ::vg::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Mapping::set_allocated_position(::vg::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Mapping.position)
}

// repeated .vg.Edit edit = 2;
inline int Mapping::edit_size() const {
  return edit_.size();
}
inline void Mapping::clear_edit() {
  edit_.Clear();
}
inline const ::vg::Edit& Mapping::edit(int index) const {
  // @@protoc_insertion_point(field_get:vg.Mapping.edit)
  return edit_.Get(index);
}
inline ::vg::Edit* Mapping::mutable_edit(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Mapping.edit)
  return edit_.Mutable(index);
}
inline ::vg::Edit* Mapping::add_edit() {
  // @@protoc_insertion_point(field_add:vg.Mapping.edit)
  return edit_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Edit >*
Mapping::mutable_edit() {
  // @@protoc_insertion_point(field_mutable_list:vg.Mapping.edit)
  return &edit_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Edit >&
Mapping::edit() const {
  // @@protoc_insertion_point(field_list:vg.Mapping.edit)
  return edit_;
}

// optional int64 rank = 5;
inline void Mapping::clear_rank() {
  rank_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Mapping::rank() const {
  // @@protoc_insertion_point(field_get:vg.Mapping.rank)
  return rank_;
}
inline void Mapping::set_rank(::google::protobuf::int64 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:vg.Mapping.rank)
}

// optional .vg.Metadata metadata = 4;
inline bool Mapping::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Mapping::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Mapping::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Mapping.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Mapping::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Mapping.metadata)
  return metadata_;
}
inline ::vg::Metadata* Mapping::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Mapping::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Mapping.metadata)
}

// -------------------------------------------------------------------

// Position

// optional int64 node_id = 1;
inline void Position::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Position::node_id() const {
  // @@protoc_insertion_point(field_get:vg.Position.node_id)
  return node_id_;
}
inline void Position::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.node_id)
}

// optional int64 offset = 2;
inline void Position::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Position::offset() const {
  // @@protoc_insertion_point(field_get:vg.Position.offset)
  return offset_;
}
inline void Position::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.offset)
}

// optional .vg.Metadata metadata = 3;
inline bool Position::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Position::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Position::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Position.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Position::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Position.metadata)
  return metadata_;
}
inline ::vg::Metadata* Position::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Position::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Position.metadata)
}

// optional bool is_reverse = 4;
inline void Position::clear_is_reverse() {
  is_reverse_ = false;
}
inline bool Position::is_reverse() const {
  // @@protoc_insertion_point(field_get:vg.Position.is_reverse)
  return is_reverse_;
}
inline void Position::set_is_reverse(bool value) {
  
  is_reverse_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.is_reverse)
}

// -------------------------------------------------------------------

// Path

// optional string name = 1;
inline void Path::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Path::name() const {
  // @@protoc_insertion_point(field_get:vg.Path.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Path::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Path.name)
}
inline void Path::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Path.name)
}
inline void Path::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Path.name)
}
inline ::std::string* Path::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Path.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Path::release_name() {
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Path::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Path.name)
}

// repeated .vg.Mapping mapping = 2;
inline int Path::mapping_size() const {
  return mapping_.size();
}
inline void Path::clear_mapping() {
  mapping_.Clear();
}
inline const ::vg::Mapping& Path::mapping(int index) const {
  // @@protoc_insertion_point(field_get:vg.Path.mapping)
  return mapping_.Get(index);
}
inline ::vg::Mapping* Path::mutable_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Path.mapping)
  return mapping_.Mutable(index);
}
inline ::vg::Mapping* Path::add_mapping() {
  // @@protoc_insertion_point(field_add:vg.Path.mapping)
  return mapping_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Mapping >*
Path::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable_list:vg.Path.mapping)
  return &mapping_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Mapping >&
Path::mapping() const {
  // @@protoc_insertion_point(field_list:vg.Path.mapping)
  return mapping_;
}

// optional .vg.Metadata metadata = 3;
inline bool Path::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Path::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Path::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Path.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Path::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Path.metadata)
  return metadata_;
}
inline ::vg::Metadata* Path::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Path::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Path.metadata)
}

// -------------------------------------------------------------------

// Alignment

// optional string sequence = 1;
inline void Alignment::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.sequence)
}
inline void Alignment::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.sequence)
}
inline void Alignment::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.sequence)
}
inline ::std::string* Alignment::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_sequence() {
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.sequence)
}

// optional .vg.Path path = 2;
inline bool Alignment::has_path() const {
  return !_is_default_instance_ && path_ != NULL;
}
inline void Alignment::clear_path() {
  if (GetArenaNoVirtual() == NULL && path_ != NULL) delete path_;
  path_ = NULL;
}
inline const ::vg::Path& Alignment::path() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.path)
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::vg::Path* Alignment::mutable_path() {
  
  if (path_ == NULL) {
    path_ = new ::vg::Path;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.path)
  return path_;
}
inline ::vg::Path* Alignment::release_path() {
  
  ::vg::Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline void Alignment::set_allocated_path(::vg::Path* path) {
  delete path_;
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.path)
}

// optional string name = 3;
inline void Alignment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::name() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.name)
}
inline void Alignment::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.name)
}
inline void Alignment::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.name)
}
inline ::std::string* Alignment::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_name() {
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.name)
}

// optional bytes quality = 4;
inline void Alignment::clear_quality() {
  quality_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::quality() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.quality)
  return quality_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_quality(const ::std::string& value) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.quality)
}
inline void Alignment::set_quality(const char* value) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.quality)
}
inline void Alignment::set_quality(const void* value, size_t size) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.quality)
}
inline ::std::string* Alignment::mutable_quality() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.quality)
  return quality_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_quality() {
  
  return quality_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_quality(::std::string* quality) {
  if (quality != NULL) {
    
  } else {
    
  }
  quality_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quality);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.quality)
}

// optional int32 mapping_quality = 5;
inline void Alignment::clear_mapping_quality() {
  mapping_quality_ = 0;
}
inline ::google::protobuf::int32 Alignment::mapping_quality() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mapping_quality)
  return mapping_quality_;
}
inline void Alignment::set_mapping_quality(::google::protobuf::int32 value) {
  
  mapping_quality_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.mapping_quality)
}

// optional int32 score = 6;
inline void Alignment::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 Alignment::score() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.score)
  return score_;
}
inline void Alignment::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.score)
}

// optional int32 query_position = 7;
inline void Alignment::clear_query_position() {
  query_position_ = 0;
}
inline ::google::protobuf::int32 Alignment::query_position() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.query_position)
  return query_position_;
}
inline void Alignment::set_query_position(::google::protobuf::int32 value) {
  
  query_position_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.query_position)
}

// optional string sample_name = 9;
inline void Alignment::clear_sample_name() {
  sample_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::sample_name() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.sample_name)
  return sample_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_sample_name(const ::std::string& value) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.sample_name)
}
inline void Alignment::set_sample_name(const char* value) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.sample_name)
}
inline void Alignment::set_sample_name(const char* value, size_t size) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.sample_name)
}
inline ::std::string* Alignment::mutable_sample_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.sample_name)
  return sample_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_sample_name() {
  
  return sample_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_sample_name(::std::string* sample_name) {
  if (sample_name != NULL) {
    
  } else {
    
  }
  sample_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sample_name);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.sample_name)
}

// optional string read_group = 10;
inline void Alignment::clear_read_group() {
  read_group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::read_group() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_group)
  return read_group_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_read_group(const ::std::string& value) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.read_group)
}
inline void Alignment::set_read_group(const char* value) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.read_group)
}
inline void Alignment::set_read_group(const char* value, size_t size) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.read_group)
}
inline ::std::string* Alignment::mutable_read_group() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.read_group)
  return read_group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_read_group() {
  
  return read_group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_read_group(::std::string* read_group) {
  if (read_group != NULL) {
    
  } else {
    
  }
  read_group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), read_group);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.read_group)
}

// optional .vg.Alignment fragment_prev = 11;
inline bool Alignment::has_fragment_prev() const {
  return !_is_default_instance_ && fragment_prev_ != NULL;
}
inline void Alignment::clear_fragment_prev() {
  if (GetArenaNoVirtual() == NULL && fragment_prev_ != NULL) delete fragment_prev_;
  fragment_prev_ = NULL;
}
inline const ::vg::Alignment& Alignment::fragment_prev() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_prev)
  return fragment_prev_ != NULL ? *fragment_prev_ : *default_instance_->fragment_prev_;
}
inline ::vg::Alignment* Alignment::mutable_fragment_prev() {
  
  if (fragment_prev_ == NULL) {
    fragment_prev_ = new ::vg::Alignment;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_prev)
  return fragment_prev_;
}
inline ::vg::Alignment* Alignment::release_fragment_prev() {
  
  ::vg::Alignment* temp = fragment_prev_;
  fragment_prev_ = NULL;
  return temp;
}
inline void Alignment::set_allocated_fragment_prev(::vg::Alignment* fragment_prev) {
  delete fragment_prev_;
  fragment_prev_ = fragment_prev;
  if (fragment_prev) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_prev)
}

// optional .vg.Alignment fragment_next = 12;
inline bool Alignment::has_fragment_next() const {
  return !_is_default_instance_ && fragment_next_ != NULL;
}
inline void Alignment::clear_fragment_next() {
  if (GetArenaNoVirtual() == NULL && fragment_next_ != NULL) delete fragment_next_;
  fragment_next_ = NULL;
}
inline const ::vg::Alignment& Alignment::fragment_next() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_next)
  return fragment_next_ != NULL ? *fragment_next_ : *default_instance_->fragment_next_;
}
inline ::vg::Alignment* Alignment::mutable_fragment_next() {
  
  if (fragment_next_ == NULL) {
    fragment_next_ = new ::vg::Alignment;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_next)
  return fragment_next_;
}
inline ::vg::Alignment* Alignment::release_fragment_next() {
  
  ::vg::Alignment* temp = fragment_next_;
  fragment_next_ = NULL;
  return temp;
}
inline void Alignment::set_allocated_fragment_next(::vg::Alignment* fragment_next) {
  delete fragment_next_;
  fragment_next_ = fragment_next;
  if (fragment_next) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_next)
}

// optional bytes data = 13;
inline void Alignment::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::data() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.data)
}
inline void Alignment::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.data)
}
inline void Alignment::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.data)
}
inline ::std::string* Alignment::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_data() {
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.data)
}

// optional .vg.Metadata metadata = 14;
inline bool Alignment::has_metadata() const {
  return !_is_default_instance_ && metadata_ != NULL;
}
inline void Alignment::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::vg::Metadata& Alignment::metadata() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::vg::Metadata* Alignment::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::vg::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.metadata)
  return metadata_;
}
inline ::vg::Metadata* Alignment::release_metadata() {
  
  ::vg::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Alignment::set_allocated_metadata(::vg::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.metadata)
}

// optional bool is_secondary = 15;
inline void Alignment::clear_is_secondary() {
  is_secondary_ = false;
}
inline bool Alignment::is_secondary() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.is_secondary)
  return is_secondary_;
}
inline void Alignment::set_is_secondary(bool value) {
  
  is_secondary_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.is_secondary)
}

// -------------------------------------------------------------------

// Fragment

// repeated .vg.Alignment alignment = 1;
inline int Fragment::alignment_size() const {
  return alignment_.size();
}
inline void Fragment::clear_alignment() {
  alignment_.Clear();
}
inline const ::vg::Alignment& Fragment::alignment(int index) const {
  // @@protoc_insertion_point(field_get:vg.Fragment.alignment)
  return alignment_.Get(index);
}
inline ::vg::Alignment* Fragment::mutable_alignment(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Fragment.alignment)
  return alignment_.Mutable(index);
}
inline ::vg::Alignment* Fragment::add_alignment() {
  // @@protoc_insertion_point(field_add:vg.Fragment.alignment)
  return alignment_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Alignment >*
Fragment::mutable_alignment() {
  // @@protoc_insertion_point(field_mutable_list:vg.Fragment.alignment)
  return &alignment_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Alignment >&
Fragment::alignment() const {
  // @@protoc_insertion_point(field_list:vg.Fragment.alignment)
  return alignment_;
}

// -------------------------------------------------------------------

// KmerMatch

// optional string sequence = 1;
inline void KmerMatch::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KmerMatch::sequence() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KmerMatch::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.KmerMatch.sequence)
}
inline void KmerMatch::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.KmerMatch.sequence)
}
inline void KmerMatch::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.KmerMatch.sequence)
}
inline ::std::string* KmerMatch::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.KmerMatch.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KmerMatch::release_sequence() {
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KmerMatch::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.KmerMatch.sequence)
}

// optional int64 node_id = 2;
inline void KmerMatch::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KmerMatch::node_id() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.node_id)
  return node_id_;
}
inline void KmerMatch::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.node_id)
}

// optional sint32 position = 3;
inline void KmerMatch::clear_position() {
  position_ = 0;
}
inline ::google::protobuf::int32 KmerMatch::position() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.position)
  return position_;
}
inline void KmerMatch::set_position(::google::protobuf::int32 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.position)
}

// optional bool backward = 4;
inline void KmerMatch::clear_backward() {
  backward_ = false;
}
inline bool KmerMatch::backward() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.backward)
  return backward_;
}
inline void KmerMatch::set_backward(bool value) {
  
  backward_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.backward)
}

// -------------------------------------------------------------------

// BasePileup

// optional int32 ref_base = 1;
inline void BasePileup::clear_ref_base() {
  ref_base_ = 0;
}
inline ::google::protobuf::int32 BasePileup::ref_base() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.ref_base)
  return ref_base_;
}
inline void BasePileup::set_ref_base(::google::protobuf::int32 value) {
  
  ref_base_ = value;
  // @@protoc_insertion_point(field_set:vg.BasePileup.ref_base)
}

// optional int32 num_bases = 2;
inline void BasePileup::clear_num_bases() {
  num_bases_ = 0;
}
inline ::google::protobuf::int32 BasePileup::num_bases() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.num_bases)
  return num_bases_;
}
inline void BasePileup::set_num_bases(::google::protobuf::int32 value) {
  
  num_bases_ = value;
  // @@protoc_insertion_point(field_set:vg.BasePileup.num_bases)
}

// optional string bases = 3;
inline void BasePileup::clear_bases() {
  bases_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasePileup::bases() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.bases)
  return bases_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_bases(const ::std::string& value) {
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.BasePileup.bases)
}
inline void BasePileup::set_bases(const char* value) {
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.BasePileup.bases)
}
inline void BasePileup::set_bases(const char* value, size_t size) {
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.BasePileup.bases)
}
inline ::std::string* BasePileup::mutable_bases() {
  
  // @@protoc_insertion_point(field_mutable:vg.BasePileup.bases)
  return bases_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasePileup::release_bases() {
  
  return bases_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_allocated_bases(::std::string* bases) {
  if (bases != NULL) {
    
  } else {
    
  }
  bases_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bases);
  // @@protoc_insertion_point(field_set_allocated:vg.BasePileup.bases)
}

// optional bytes qualities = 4;
inline void BasePileup::clear_qualities() {
  qualities_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasePileup::qualities() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.qualities)
  return qualities_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_qualities(const ::std::string& value) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.BasePileup.qualities)
}
inline void BasePileup::set_qualities(const char* value) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.BasePileup.qualities)
}
inline void BasePileup::set_qualities(const void* value, size_t size) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.BasePileup.qualities)
}
inline ::std::string* BasePileup::mutable_qualities() {
  
  // @@protoc_insertion_point(field_mutable:vg.BasePileup.qualities)
  return qualities_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasePileup::release_qualities() {
  
  return qualities_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_allocated_qualities(::std::string* qualities) {
  if (qualities != NULL) {
    
  } else {
    
  }
  qualities_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qualities);
  // @@protoc_insertion_point(field_set_allocated:vg.BasePileup.qualities)
}

// -------------------------------------------------------------------

// NodePileup

// optional int64 node_id = 1;
inline void NodePileup::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NodePileup::node_id() const {
  // @@protoc_insertion_point(field_get:vg.NodePileup.node_id)
  return node_id_;
}
inline void NodePileup::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.NodePileup.node_id)
}

// repeated .vg.BasePileup base_pileup = 2;
inline int NodePileup::base_pileup_size() const {
  return base_pileup_.size();
}
inline void NodePileup::clear_base_pileup() {
  base_pileup_.Clear();
}
inline const ::vg::BasePileup& NodePileup::base_pileup(int index) const {
  // @@protoc_insertion_point(field_get:vg.NodePileup.base_pileup)
  return base_pileup_.Get(index);
}
inline ::vg::BasePileup* NodePileup::mutable_base_pileup(int index) {
  // @@protoc_insertion_point(field_mutable:vg.NodePileup.base_pileup)
  return base_pileup_.Mutable(index);
}
inline ::vg::BasePileup* NodePileup::add_base_pileup() {
  // @@protoc_insertion_point(field_add:vg.NodePileup.base_pileup)
  return base_pileup_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >*
NodePileup::mutable_base_pileup() {
  // @@protoc_insertion_point(field_mutable_list:vg.NodePileup.base_pileup)
  return &base_pileup_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >&
NodePileup::base_pileup() const {
  // @@protoc_insertion_point(field_list:vg.NodePileup.base_pileup)
  return base_pileup_;
}

// -------------------------------------------------------------------

// Genotype

// repeated .vg.Path allele = 1;
inline int Genotype::allele_size() const {
  return allele_.size();
}
inline void Genotype::clear_allele() {
  allele_.Clear();
}
inline const ::vg::Path& Genotype::allele(int index) const {
  // @@protoc_insertion_point(field_get:vg.Genotype.allele)
  return allele_.Get(index);
}
inline ::vg::Path* Genotype::mutable_allele(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Genotype.allele)
  return allele_.Mutable(index);
}
inline ::vg::Path* Genotype::add_allele() {
  // @@protoc_insertion_point(field_add:vg.Genotype.allele)
  return allele_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Path >*
Genotype::mutable_allele() {
  // @@protoc_insertion_point(field_mutable_list:vg.Genotype.allele)
  return &allele_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
Genotype::allele() const {
  // @@protoc_insertion_point(field_list:vg.Genotype.allele)
  return allele_;
}

// optional .vg.Position start = 2;
inline bool Genotype::has_start() const {
  return !_is_default_instance_ && start_ != NULL;
}
inline void Genotype::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) delete start_;
  start_ = NULL;
}
inline const ::vg::Position& Genotype::start() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::vg::Position* Genotype::mutable_start() {
  
  if (start_ == NULL) {
    start_ = new ::vg::Position;
  }
  // @@protoc_insertion_point(field_mutable:vg.Genotype.start)
  return start_;
}
inline ::vg::Position* Genotype::release_start() {
  
  ::vg::Position* temp = start_;
  start_ = NULL;
  return temp;
}
inline void Genotype::set_allocated_start(::vg::Position* start) {
  delete start_;
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Genotype.start)
}

// optional .vg.Position end = 3;
inline bool Genotype::has_end() const {
  return !_is_default_instance_ && end_ != NULL;
}
inline void Genotype::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) delete end_;
  end_ = NULL;
}
inline const ::vg::Position& Genotype::end() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::vg::Position* Genotype::mutable_end() {
  
  if (end_ == NULL) {
    end_ = new ::vg::Position;
  }
  // @@protoc_insertion_point(field_mutable:vg.Genotype.end)
  return end_;
}
inline ::vg::Position* Genotype::release_end() {
  
  ::vg::Position* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Genotype::set_allocated_end(::vg::Position* end) {
  delete end_;
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Genotype.end)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vg_2eproto__INCLUDED
